---
title: "Creating Your Own Istio (Part 2)"
date: 2018-11-07
lastmod: 2018-11-07
draft: false
keywords: []
description: "Creating our reusable container."
tags: [openshift, container, services, kubernetes ]
categories: [openshift, container, services, kubernetes ]
toc: true
image: https://github.com/cesarvr/hugo-blog/blob/master/static/static/logo/ocp.png?raw=true
---

Let's create a container capable of enhancing or adding new features to any service in our cluster, independently of the technology they are made of as long as they talk the same protocol (HTTP 1.xx).

<!--more-->


# Proxy Server

A good starting point for our container is that it should be able to sit in front of other processes and act as a proxy. To make things easier I wrote an API called [node-ambassador](https://www.npmjs.com/package/node-ambassador) in JavaScript.

Let's create a Node.JS project and fetch the library using [NPM](https://www.npmjs.com):

```sh
  mkdir /<project-folder>
  cd /<folder-project>

  npm init # creates the package.json
  npm install node-ambassador --save #install library
```

The boiler plate code to initialize the library:

```js
  let { Ambassador }  = require('../node-ambassador/')
  const TARGET = process.env['target_port'] || 8087
  const PORT   = process.env['port'] || 8080

  new Ambassador({port: PORT, target: TARGET})
        .tunnel({})

  console.log(`listening for request in ${PORT} and targeting ${TARGET}`)
```

To configure our proxy we need a ``PORT`` to listen for new request and a ``TARGET_PORT`` to send the request.

We create a new *Ambassador* object and call the ``tunnel`` method which as the name implies tunnels the communication to the ``TARGET_PORT``.

### Testing

To test our program we just need to run a process in the same IP address capable of understanding HTTP (version 1.+), Python [simple server module](https://docs.python.org/2/library/simplehttpserver.html) is more that good for testing purposes.

Assuming you have Python installed, just execute this:

```sh
  python -m SimpleHTTPServer 8087
```

Also you can use [Docker](https://dzone.com/articles/docker-for-beginners):

```sh
cd /<folder-you-want-serve>

#copy & paste this line
sudo docker run -it -v "$(pwd)":/app:z -p 8087:8087 --name py-server python python -m http.server 8087 --directory /app/

#stop
docker stop py-server

#start
docker start py-server
```
Live example:

![](https://raw.githubusercontent.com/cesarvr/hugo-blog/master/static/istio-2/python-server.gif)

This server will use the *port 8087* to serve its contents.

#### Testing Our Tunnel

To execute our script we need to configure the environment variables, ``TARGET_PORT`` to target the Python server and ``PORT`` the TCP port we want to listen to.

```sh
export PORT=8080
export TARGET_PORT=8087

node app.js
```

![proxy-v1](https://github.com/cesarvr/hugo-blog/blob/master/static/istio-2/proxy-v1.gif?raw=true)
> In this example I just pick another image folder.

## More Than Just Proxy

Right now program is just a proxy server, let's write some features to make it more interesting.

### Overriding Responses

To keep things simple we are going to implement a reusable 404 web page. Any time we want to override the 404 of a particular service we just need to install and configure our container as we going to do later.

To start we can define our 404 page using this [constant string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals).

```js
const HTTP404 = `
HTTP/1.0 404 File not found
Server: Sitio ðŸ’¥
Date: ${Date()}
Content-Type: text/html
Connection: close

<body>
  <H1>Look Somewhere Else /  Not Found</H1>
  <img src="https://www.wykop.pl/cdn/c3201142/comment_E6icBQJrg2RCWMVsTm4mA3XdC9yQKIjM.gif">
</body>`
```

First of all we need to look at the traffic passing through our proxy, we can do that by adding a subscriber object to the ``tunnel`` method.

```js
let subscriber = ({request, response}) => {}

new Ambassador({port: PORT, target: TARGET})
      .tunnel({ subscriber })
```

This subscriber methods provide two objects, the **request** object which controls the flow of data coming from the initiator of the request (i.e., browser) and the **response** object which allow us to manipulate the traffic generated by the service i.e., our Python web server.

Let's focus in the ``subscriber`` function and monitor the service responses.

```js
let subscriber = ({request, response}) => {
  response.listen((header) => {    // monitor responses
    if(header.status === '404')  
     console.log('do something...')
  })
}
```
The header object returns the HTTP status header we lookup for the status field and check if its 404. If the condition is true we need need to call the ``override`` method, which suspend all the traffic and override the response.

```js

const HTTP404 = `...`

let subscriber = ({request, response}) => {
  response.listen((header) => {    // monitor responses
    if(header.status === '404')  
      response.override(HTTP404)
  })
}
```

Now our web server is being decorated with a new  functionality:

![proxy-v2](https://github.com/cesarvr/hugo-blog/blob/master/static/istio-2/proxy-v2.gif?raw=true)


## Creating Our Ambassador Container

Now we got some behaviour in the form of a 404 page, we are going to reuse this code with two services written in totally different technologies. If you get lost in some Kubernetes/OpenShift jargon just take a look at this [getting started guide](https://github.com/cesarvr/Openshift).

Our first step is to create a [build configuration](https://cesarvr.io/post/buildconfig/) capable of transforming our project into a container.

#### Project Configuration

The Node.JS build configuration expects that our project to be able to run using [npm start](https://docs.npmjs.com/cli/start), so we need to enable this.

Open the ``package.json`` and add this:

```js
  "start" : "node app.js"      
```

Inside the *scripts* section:

```json
{
  "name": "sitio",
  "version": "1.0.0",
  "description": "",
  "main": "app.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start" : "node app.js"      
  },
  "author": "",
  "license": "ISC"
}
```

This should work now:

```js
  npm start
```

#### Build Configuration

Next, we need create a new binary build:

```sh
oc new-build nodejs --binary=true --name=decorator
```

Now we need to run the build and lookup for the generated image:

```sh
  #cd /jump-to-your-script-folder

  oc start-build bc/decorator --from-dir=.

  #Uploading directory "." as binary input for the build ...
  #build "decorator-1" started
  #....
  #....


  oc get is
  #NAME        DOCKER REPO                       ...
  #decorator   172.30.1.1:5000/hello/decorator   ...
```

Our image is stored here: ``172.30.1.1:5000/hello/decorator``

![](https://raw.githubusercontent.com/cesarvr/hugo-blog/master/static/istio-2/start-build.gif)

### Pod

If you remember the [first article](https://cesarvr.io/post/istio/) we build our *pod* using this simple template:

```xml
apiversion: v1
kind: Pod
metadata:
  name: my-pod
  labels:
    app: my-pod
spec:
  containers:
  - name: web
    image: docker-registry.default.svc:5000/web-apps/web
    command: ['sh', '-c', 'cd static && python -m http.server 8087']
  - name: proxy
    image: busybox
    command: ['sh', '-c', 'echo Hello World 2 && sleep 3600']
```

This template deploys two containers:

- **web** running a python web server
- **proxy** running a dummy sleep process.

We need to replace the image for the **proxy** (``busybox``) with the one generated by our build:

```xml
apiversion: v1
kind: Pod
metadata:
  name: my-pod
  labels:
    app: my-pod
spec:
 containers:
 - name: web
   image: docker-registry.default.svc:5000/web-apps/web
   command: ['sh', '-c', 'cd static && python -m http.server 8087']
 - name: proxy
   port: 8080
   image: 172.30.1.1:5000/hello/decorator
```
We removed the ``command`` section as its no longer necessary and added a TCP port 8080 to be expose.


### Exposing Our Pod

Let's send some traffic to our pod.

```sh
  oc create service loadbalancer my-pod --tcp=8080:8080
```

The [OpenShift Service](https://github.com/cesarvr/Openshift#service) represents a load balancer that we can configure to send traffic to our application.

By choosing the same name ``my-pod`` it will automatically look for pods with that name and direct traffic to them using port 8080. Last step is to create a route for this Service.

```sh
  oc expose svc my-pod
```

<br>


![](https://raw.githubusercontent.com/cesarvr/hugo-blog/master/static/istio-2/decorating%20a%20service.gif)

> Here we are running a Python service, enhanced with our container.

### Reusing our 404 Page with a Java Micro-services

For this particular case, the Java application is not following the good practice of setting up the listening port using environment variables, but fortunately our container follow those rules.

So what I did was to install the container and then configure the environment variable.

```sh
 oc set env -c decorator dc/slow-j TARGET_PORT=8080 PORT=8087
```

Then modify the OpenShift Service to target the right port.

![](https://raw.githubusercontent.com/cesarvr/ambassador/master/assets/final.gif)

> Here we are running a Java service, enhanced with our container.

<br>
![](https://raw.githubusercontent.com/cesarvr/hugo-blog/master/static/istio-2/design.svg?sanitize=true)
<br>

Those logs you see in the right section of the image is a *telemetry* mechanism I implemented as reusable feature for the whole main container, I didn't include how to do it in this post because I wanted to keep this post short, but I will include it in the next post.

By know you should be able to experiment yourself using this API (our creating your own API in any other language) and coming up with new usages like creating a robot that detect/report crashes in your services.

Here is the code for the [ambassador container](https://github.com/cesarvr/ambassador) and also feel free to contribute to the [node-ambassador](https://github.com/cesarvr/node-ambassador) API in GitHub, with any missing features, improvement, etc.
