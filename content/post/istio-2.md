---
title: "Creating Your Own Istio (Part 2)"
date: 2018-11-07
lastmod: 2018-11-07
draft: false
keywords: []
description: "Creating our reusable container."
tags: [openshift, container, services, kubernetes ]
categories: [openshift, container, services, kubernetes ]
toc: true
image: https://github.com/cesarvr/hugo-blog/blob/master/static/static/logo/ocp.png?raw=true
---
## Getting Started

Metaphors aside we want to create a service that takes an HTTP request, do something with that information, proxy this request to other service and handle the response of this service to the request originator. 



## How To Make A Proxy

### Incoming Traffic

To handle the incoming traffic we can start by writing a simple [socket](http://man7.org/linux/man-pages/man2/socket.2.html) server.

```js
var net = require('net')

console.log('Listening for request in 8080')
net.createServer( function (socket) {

  console.log('new connection!')
  socket.end()

}).listen(8080)
```

The first thing to do is require the NodeJS [the network library](https://nodejs.org/api/net.html) and creates a new server which listen to the port 8080.

We save this in a file (``sitio.js``) and run it:

```sh
  node sitio.js
  # Listening for request in 8080
```

If we connect with [curl](https://linux.die.net/man/1/curl) we should get this message back:

```sh 
  curl -v 0.0.0.0:8080
  # ...
  #* Empty reply from server
  #* Connection #0 to host 0.0.0.0 left intact
```

### Incoming Traffic 

We are going to separate the different behaviors of our *proxy* process in classes, the first class we are going to write will take care of the traffic generated by the connection of a new client.

```js
class IncomingTraffic {
  constructor({socket}) {
    this.socket = socket
  }
}
```
### Output

To control the output we are going to write a simple method that just push information to the socket, using socket [write](https://nodejs.org/api/net.html#net_socket_write_data_encoding_callback) method.

```js
class IncomingTraffic {
  constructor({socket}) {
    //..
  }

  send(chucks){
    chucks.forEach(data => this.socket.write(data) )
    this.socket.end() //close socket connection
  }
}
```


### Input

Node.JS uses events to notify the processes of any I/O operation coming from the OS, meaning that if we want to capture data flowing to the socket we need to subscribe to the proper event.  

```js
    this.socket.on('data', data => console.log(data))
```

Here we subscribe to [data event.](https://nodejs.org/api/net.html#net_event_data)


### Event Driven

Our object looks great, but we need to share this object knowledge about the incoming data somehow. We could inject through the constructor, but this may create a dependency issue. To avoid injecting any dependencies, we are going to inform other objects by using events. 

First we need to require the NodeJS [Events](https://nodejs.org/api/events.html) library. 

```js
 let Events = require('Events')
``` 

We are going to reuse this library by using inheritance.

```js
class IncomingTraffic extends Events {
  constructor({socket}) {
    super() // JS need this to allow inheritance.
    //...
  }

}
```

When new data arrives, we just delegate it using the **Event** inherited method [emit](https://nodejs.org/api/events.html#events_emitter_emit_eventname_args).


```js 
class IncomingTraffic extends Events {
  constructor({socket}) {
    super() // JS need this to allow inheritance.
    this.socket.on('data', data => this.emit('traffic:incoming', data))
    //...
  }
}
`
```

Now our class is able to hide the implementation details: 

```js
  let traffic = new IncomingTraffic({socket})

  traffic.on('traffic:incoming', function do_something() { } )
```

### Implementing A 404 Page

Here I would like to change the empty response message with a proper 404 page.

Let's declare our HTML page. 

```js
const HTTP404 = `
HTTP/1.0 404 File not found
Server: Sitio ðŸ’¥
Date: ${Date()}
Content-Type: text/html
Connection: close

<body>
  <H1>Endpoint Not Found</H1>
  <img src="https://www.wykop.pl/cdn/c3201142/comment_E6icBQJrg2RCWMVsTm4mA3XdC9yQKIjM.gif">
</body>`
```

Let's use the *Incomming Traffic* class to manage the response: 

```js
function handle(socket) {
  let traffic = new IncomingTraffic({socket})

  traffic.on('traffic:new', incomingData => traffic.send([HTTP404]))
}

console.log('Listening for request in 8087!!')
net.createServer( function (socket) {
  console.log('new connection!')
  handle(socket)
}).listen(8087)
```

If we execute our code now we should see our 404 page:

![HTTP 404](https://raw.githubusercontent.com/cesarvr/hugo-blog/master/static/istio-2/404.png)



## Making A Tunnel

###Â Connecting

We've solve so far the incoming traffic part, now let's work on how to proxy this traffic to other services. 

We can start by opening a TCP connection connection with the service.

```js
class Service  {
  constructor(port) {
    port = port || 8087  // we initialise this to 8087 in case of undefined
    let client = new net.Socket()

    client.connect(port, '0.0.0.0', () => {
      console.log(`connected to ${port}`)
    })
  }
}
```

Following our OOP approach, we want to handle everything related to other services in this *Service* class, in the constructor we create a new client socket which connect to any service running in the same host, using the port 8087. 

To target any arbitrary port we added the option to pass the port number in the constructor:

```js
  let service = new Service({port: process.env['SVC_PORT']})
```

### Events and I/O

```js
class Service extends Events {
  constructor(_port) {
    //..
    // this event can get called multiple time... we buffer the content
    // into the read method.
    client.on('data', data => this.read(data))

    this.client = client
    this.buffer = []
  }

  send(data) {
    this.client.write(data)
  }

  read(data){
    this.buffer.push(data)
  }
 }
}
```

This is basically represent the same input/output handling that we did before with the class *IncomingTraffic*, the only difference is here we save the chunks in an array in the *read* method.


```js
class Service extends Events {
  constructor(_port) {
    super() 
    //...
    // When the service finish transmitting the response
    // end get called.
    client.on('end', data  => this.finish(data))

    this.client = client
    this.buffer = []
  }
  //..

  finish(){
    this.emit('service:response:200', this.buffer)
  }
}
```


We introduce a new event called ``end``, this event get triggered when the other end close connection which usually happens when the service finish the transmission.  

### Implementation

The implementation of our tunnel goes like this.

```js
function handle(socket) {
  let service = new Service()
  let traffic = new IncomingTraffic({socket})

  traffic.on('traffic:new', incomingData => service.send(incomingData))
  service.on('service:response:200', response => traffic.send(response) )
}

console.log('Listening for request in 8087!!')
net.createServer( function (socket) {
  console.log('new connection!')
  handle(socket)
}).listen(8087)
```

- When receive new traffic from TCP client, we delegate this data to the **service object**.
- When the service response we delegate the response to the **traffic object**.

We got ourselves a tunnel:

![](https://github.com/cesarvr/hugo-blog/blob/master/static/istio-2/tunel.gif?raw=true)

We execute a web server using Python running at *port 8087*, and after that we run our "Proxy" which tunnel the traffic successfully. The only problem here is that our service is not showing our 404 page, it's acting just as a mere proxy server, let's fix that.


### Overriding Responses

To implement this feature we need to identify the response state of the service, we can do this by examining the HTTP response header.

A typical response looks like this:

```xml
HTTP/1.0 200 OK
Server: Awesome Server 1.0
Date: Wed, 14 Nov 2018 15:50:49 GMT
...
```

We are just interested in the status code, which in a multi-chunk response should be part of the first block:


```js
class Service extends Events {

  // More methods

  finish(){
    let head = this.buffer[0]  // first block...
  }
}
```

We create something similar to an static object called ``http`` to handle the HTTP protocol. 

```js
let http = object.create({
  getstatus: function(data){
  }
})
```

We take the block and split it by line (`` \n ``).

```js
let http = object.create({
  getstatus: function(data){
    let headerFirstLine = data.toString().split('\n')[0]

  }
})

```

We got this: 

```xml
HTTP/1.0 200 OK
```

No we make a simple function to extract the status code.

```js
let http = object.create({
  getstatus: function(data){
    let headerFirstLine = data.toString().split('\n')[0]
    let status = headerFirstLine.split(' ')[1].trim()
    return status
  }
})
```

Here we divide the string by spaces and we choose the first occurrence ``200``. Now that we can retrieve the status code. 

It make sense that we take the states returned by the service to create new events.

```js
class Service extends Events {

  // More methods

  finish(){
    let status = HTTP.getStatus(this.buffer[0])
    this.emit(`service:response:${status}`, this.buffer)
  }
}
```

This allow us to define behavior to each event: 

```js
  service.on('service:response:200', response => traffic.send(response) )
  service.on('service:response:500', response => turn_on_alarm )
  service.on('service:response:500', response => send_email_to )
```


For our particular case we can now override the 404 response we our custom one.

```js
function handle(socket) {
  let service = new Service({port: 8087})
  let traffic = new IncomingTraffic({socket})

  traffic.on('traffic:incoming', incomingData => service.send(incomingData))

  service.on('service:response:200', response => traffic.send(response) )
  service.on('service:response:404', response => traffic.send([HTTP404]) )
}
```

**Conclusione!**
Couple of days ago this [Istio demo](https://youtu.be/gauOI0O9fRM?t=1720) where Istio was able to mask services failures (HTTP 500) by returning a cached response, I don't consider that a good idea, but the question is you are able to implement it?.


# Decorating Services

## Before We Start

Here we are going to do some Kubernetes/OpenShift heavy stuff, if you get lost with some *buzz words*, You can get up to speed by looking at this [getting started guide](https://github.com/cesarvr/Openshift).

## Running A Service

Let's test deploy our creation in Kubernetes/OpenShift. If you remember the [first article](https://cesarvr.io/post/istio/) we build our *pod* using this template:

```xml
apiversion: v1
kind: Pod
metadata:
  name: my-pod
  labels:
    app: my-pod
spec:
  containers:
  - name: web
    image: docker-registry.default.svc:5000/web-apps/web
    command: ['sh', '-c', 'cd static && python -m http.server 8087']
 - name: proxy
    image: busybox
    command: ['sh', '-c', 'echo Hello World 2 && sleep 3600']
```

This pod execute a web server, the same web server we used for testing our tunnel but this time running inside a container.

## Exposing Server Ports

This web server is using the [port 8087](https://gist.github.com/cesarvr/cecaf693a17b6f09b9eb3f5d38f33165#file-my-pod-yml-L11), this mean we need to tell the pod to expose this port:

```xml
apiversion: v1
kind: Pod
metadata:
  name: my-pod
  labels:
    app: my-pod
spec:
  containers:
  - name: web
    image: docker-registry.default.svc:5000/web-apps/web
    command: ['sh', '-c', 'cd static && python -m http.server 8087']
    port: 8087   
 - name: proxy
    image: busybox
    command: ['sh', '-c', 'echo Hello World 2 && sleep 3600']
```

We save the template above as ``pod.yml`` and we use it to create our pod:

```sh
 oc create -f pod.yml
```

This template will create two containers.

![](https://github.com/cesarvr/hugo-blog/blob/master/static/istio-2/pod.png?raw=true)

## Sending Some Traffic

Let's send some traffic to our pod.

```sh
  oc create service loadbalancer my-pod --tcp=8087:8087
```

The [OpenShift Service](https://github.com/cesarvr/Openshift#service) represents a load balancer that we can configure to send traffic to our application. By choosing the same name ```my-pod``` it will automatically look for pods with that name and direct traffic to them using port 8087.

Next step is creating a route:

```sh
oc expose svc my-pod
```

Our service is now published.

![](https://github.com/cesarvr/hugo-blog/blob/master/static/istio-2/pod-svc-routing.gif?raw=true)


We should use a deployment configuration for this but, we are focusing in the understanding of the pod entity.

## Decorating 

We are going to add our custom 404 page, by just adding a new container. 

### Making A Container

To make the container we can use OpenShift [binary build configuration](https://cesarvr.io/post/buildconfig/), this basically delegate the image creation, to OpenShift using its Node.js builder image. 

This builder configuration requires we that our Node.js project includes a `` package.json``, to include this file we can execute this command: 

```sh
cd /jump-to-your-script-folder
npm init  # Respond all the questions
```

Open the ``package.json`` and add a **start** entry in the *scripts* section:

```json
{
  "name": "sitio",
  "version": "1.0.0",
  "description": "",
  "main": "app.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start" : "node app.js"      
  },
  "author": "",
  "license": "ISC"
}
```

Now we can create our NodeJS build configuration:

```sh
  oc new-build nodejs --binary=true --name=decorator
```

Now let's copy the content of our project to the build configuration.

```sh
cd /jump-to-your-script-folder

oc start-build bc/decorator --from-dir=.
#Uploading directory "." as binary input for the build ...
#build "decorator-1" started
```

![](https://raw.githubusercontent.com/cesarvr/hugo-blog/master/static/istio-2/start-build.gif)


Once our application is build, we just need to locate the image created for us:

```sh
oc get is

#NAME        DOCKER REPO                      
#decorator   172.30.1.1:5000/home/decorator
```

And we replace the busybox image we where using this far.

```xml
  ...
  containers:
  - name: web
    image: docker-registry.default.svc:5000/web-apps/web
    command: ['sh', '-c', 'cd static && python -m http.server 8087']
    port: 8087   #
  - name: proxy
    image: 172.30.1.1:5000/home/decorator
```


Also we need to change the port exposed by the pod to 8080, which is the port our "Proxy" container will use.

```xml
apiversion: v1
kind: Pod
metadata:
  name: my-pod
  labels:
    app: my-pod
spec:
 containers:
 - name: web
   image: 172.30.1.1:5000/home/web
   command: ['sh', '-c', 'cd static && python -m http.server 8087']
 - name: proxy
   port: 8080
   image: 172.30.1.1:5000/home/decorator
```

We re-create our pod:

```sh
# Delete
oc delete pod my-pod

# Create
oc create -f pod.yml
```

And here is our decorated container.


![](https://raw.githubusercontent.com/cesarvr/hugo-blog/master/static/istio-2/decorating%20a%20service.gif)

As you see we are executing a different application from the one we tested here.
