<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  <title>Chaining Builds In Openshift - code_scripter</title>
  


  <meta name="twitter:site" content="@cvaldezr">
  <meta name="twitter:creator" content="@cvaldezr">
  <meta name="twitter:description" content="Using chained builds to improve the size of your images and overall deployment performance in Openshift." />
  <meta name="twitter:title" content="Chaining Builds In Openshift" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:image" content="" />

  <meta property="og:title" content="Chaining Builds In Openshift" />
  <meta property="og:description" content="Using chained builds to improve the size of your images and overall deployment performance in Openshift." />
  <meta property="og:image" content="" />

  <meta name="description" content="New application Creating a Node.js application in Openshift is simple:
oc login -u user oc new-project hello # Assuming you are logged and you have a project you can start here. oc new-app --name node-app nodejs~https://github.com/cesarvr/hello-world-nodejs #new app using nodejs:latest (Node.js 8)  This command will create the backbone (BuildConfig, DeploymentConfig and Service) to orchestrate the different stages from source code to a running application.
The size problem But this nice abstraction come with a cost, to explain what I mean, let&rsquo;s review size of our final image using du:">
  <meta name="author" content="Cesar Valdez">
  
  <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,700,700i" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/atom-one-dark.min.css" integrity="sha256-akwTLZec/XAFvgYgVH1T5/369lhA2Efr22xzCNl1nHs=" crossorigin="anonymous" />
  <link href="/css/style.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/css/toastr.min.css" />

  
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">
  <link rel="icon" href="/img/favicon.ico">
  
  <meta name="generator" content="Hugo 0.56.3" />
  
  <link rel="alternate" type="application/atom+xml" href="/index.xml" title="code_scripter">
  
</head>
<body class="single">
  <header class="header">
    
    <p class="title"><a href="/">code_scripter</a></p>
    
    <button class="menu-toggle" type="button"></button>
    <nav class="menu">
      <ul>
        
        
        <li class="">
          <a href="categories/">Categories</a>
        </li>
        
        <li class="">
          <a href="/about/">About</a>
        </li>
        
        <li class="">
          <a href="https://github.com/cesarvr">Code</a>
        </li>
        
        <li class="">
          <a href="/post/">Writing</a>
        </li>
        
      </ul>
    </nav>
  </header>
  <main class="main">

  <script
    			  src="https://code.jquery.com/jquery-3.3.1.min.js"
    			  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
    			  crossorigin="anonymous"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.js" async></script>
  <script src="/js/db.js"></script>

<article class="post post-view">
  <header class="post-header">
    <h1 class="post-title">Chaining Builds In Openshift</h1>
    <p class="post-meta">Cesar Valdez Â· 2018.7.21</p>
  </header>
  <div class="post-content">

<h2 id="new-application">New application</h2>

<p>Creating a Node.js application in Openshift is simple:</p>

<pre><code class="language-sh"> oc login -u user
 oc new-project hello

 # Assuming you are logged and you have a project you can start here.
 oc new-app --name node-app nodejs~https://github.com/cesarvr/hello-world-nodejs #new app using nodejs:latest (Node.js 8)
</code></pre>

<p>This command will create the backbone (BuildConfig, DeploymentConfig and Service) to orchestrate the different stages from source code to a running application.</p>

<h2 id="the-size-problem">The size problem</h2>

<p>But this nice abstraction come with a cost, to explain what I mean, let&rsquo;s review size of our final image using <a href="http://www.linfo.org/du.html">du</a>:</p>

<pre><code class="language-sh"># We log into our container and run
cd /
du -sh
474M	.
</code></pre>

<p>We found our image weight to much (474MB) relative to the amount of code we are running just (8 Byte).</p>

<pre><code class="language-js">require('http').createServer((req, res) =&gt; {
  res.end('Hello World')
}).listen(8080)
</code></pre>

<p>This happens because the tools we used at build (gcc, g++, npm, yum cache, etc.) are still present in the image inflating its final size. If you are just getting started as a developer in Openshift it may not be a big of a deal; also for quick proof of concepts is totally fine but it may have a cost for later stages like production that you may take into consideration.</p>

<h2 id="slim-is-better">Slim is better</h2>

<p>Some disadvantages of having a huge image are:</p>

<ul>
<li>Higher cost in CPU &amp; Ram to deploy your images.</li>
<li>If you have fixed resources bigger images slow deployments.</li>
<li>They add more stress on the cluster network.</li>
<li>Maintenance overhead. (You may end up maintaining dependencies your are not using)<br /></li>
</ul>

<p>If you need more reasons for more smaller containers:</p>

<p><a href="https://www.youtube.com/watch?v=wGz_cbtCiEA"><img src="https://img.youtube.com/vi/wGz_cbtCiEA/0.jpg" alt="Smaller Containers" /></a>)</p>

<h1 id="chaining-containers">Chaining containers</h1>

<p>The strategy to solve this problem is to have two images one with the tools to build the image and a second one with the essential libraries for runtime. Let&rsquo;s see how much we can improve those <strong>474M</strong>.</p>

<h2 id="builder-image">Builder image</h2>

<p>We can start by creating an image with the necessary tooling, we are going to call this image <code>builder</code>:</p>

<pre><code class="language-sh">oc new-build nodejs~https://github.com/cesarvr/hello-world-nodejs \
--context-dir=. \
--name=builder   
</code></pre>

<ul>
<li><pre><code class="language-nodejs```">
- The [repository for our code repository](https://github.com/cesarvr/hello-world-nodejs).

- ```context-dir``` This parameters tells where is the code.

This command will create two Openshift objects:


* **BuilderConfig** This object handle the image creation using [s2i](https://github.com/openshift/source-to-image).

</code></pre>

<p>sh</p></li>
</ul>

<p>#builder configuration
oc get bc<br />
NAME      TYPE       FROM      LATEST
builder   Source     Git         1</p>

<pre><code>
* **ImageStream** It's like the middleman between our image and everything else. After a successful build the resulting image is streamed here.

</code></pre>

<p>sh
oc get is
NAME          DOCKER REPO                         TAGS      UPDATED
builder       172.30.1.1:5000/hello/builder       latest    6 hours ago</p>

<pre><code>
Great!, we have our image with the tools we need. Next step is to trigger a build to prepare our application.  

![builder](https://github.com/cesarvr/hugo-blog/blob/master/static/static/chaining-build/build-tools.gif.gif?raw=true)

If everything is fine we should have all our Node.js artifacts inside a new image for us to consume, the nodejs base image we are using store the artifacts and our code in ```/opt/app-root/src/```.


## Runtime image

Now we need to create the image that will take care of the runtime. Let's start by explaining this version of the ``` oc new-build``` command:  

</code></pre>

<p>sh
oc new-build  &ndash;source-image=builder <br />
&ndash;source-image-path=[source-dir]:[destination-dir] <br />
&ndash;dockerfile=&lsquo;-&rsquo; &ndash;name=runtime</p>

<pre><code>
- ```source-image``` We want the [nodejs image we created above](#builder-image).
- ```--source-image-path``` We want to copy some files from [that image](#builder-image).
- ```dockerfile``` We want to create a new image using those files. Note: writing ```'dockerfile='-'``` will allow us to feed the Dockerfile via [standard input](https://en.wikipedia.org/wiki/Standard_streams#Standard_input_(stdin)).

Now that we know how to do it, we should create a file called [runtime.Dockerfile](https://gist.github.com/cesarvr/fac37fa7825f5ad7a576801fed07d0c8) to store the definition of our runtime container.

</code></pre>

<p>Dockerfile
FROM mhart/alpine-node:base-8
COPY * /run/
EXPOSE 8080
CMD [&ldquo;node&rdquo;, &ldquo;/run/app.js&rdquo;]</p>

<pre><code>
This file define a container using [mhart/alpine-node](https://hub.docker.com/r/mhart/alpine-node/) which is only 42 MB, next line copy the content from the *builder* image. The third and fourth line expose a port and run execute our script. This container image of course need more work to be production ready but is just fine for our purposes.


We execute the command:

</code></pre>

<p>sh
cat runtime.Dockerfile | oc new-build &ndash;name=runtime <br />
&ndash;source-image=builder <br />
&ndash;source-image-path=/opt/app-root/src:. <br />
&ndash;dockerfile=&lsquo;-&rsquo;</p>

<pre><code>
The content of [builder](#builder-image)*/opt/app-root/src/* is copy by the ```oc new-build``` into a temporary folder, then our Dockerfile use this folder as it's context folder. When we apply ```COPY * /run/``` we basically are copying the content of this folder into our new runtime container.


![runtime](https://github.com/cesarvr/hugo-blog/blob/master/static/static/chaining-build/runtime.gif?raw=true)


In the next animation you'll see how *builder* build configuration is now connected with *runtime* build. Every time *builder* push a new build of our software to the registry, it will be automatically packaged by *runtime*.

To trigger the *builder* build we just need to run:

</code></pre>

<p>oc start-build bc/builder</p>

<pre><code>
![chain](https://github.com/cesarvr/hugo-blog/blob/master/static/static/chaining-build/chain.gif?raw=true)



# Deploying our image

Is time to test if our hard work pays off. Deploying our image is very easy we just need to locate the URL of our *runtime* image in the registry:

</code></pre>

<p>sh
oc get is
#NAME          DOCKER REPO                         TAGS      UPDATED
#runtime       172.30.1.1:5000/hello/runtime       latest    15 hours ago</p>

<pre><code>
Having the address of our image, now we just simply call:

</code></pre>

<p>sh
oc create dc hello-ms &ndash;image=172.30.1.1:5000/hello/runtime</p>

<pre><code>
Now that we create our deployment object, we now need to send some traffic to our application. Before start sending traffic we need to identify by looking up is label.

</code></pre>

<p>sh
oc get dc hello-ms -o json | grep labels -A 3</p>

<h1 id="returns">returns</h1>

<p>&ldquo;labels&rdquo;: {
            &ldquo;deployment-config.name&rdquo;: &ldquo;hello-ms&rdquo;
          }</p>

<pre><code>
Now let create a service and send some traffic directed to this label:


</code></pre>

<p>sh
oc create service loadbalancer  hello-ms &ndash;tcp=80:8080</p>

<h1 id="service-hello-ms-created">service &ldquo;hello-ms&rdquo; created</h1>

<h1 id="edit-the-service-object">edit the service object</h1>

<p>oc edit svc hello-ms -o yaml</p>

<pre><code>
This will open the service object in yaml format in edit mode, we need to locate the *selector* and replace with the label of our deployment object.

From this:

</code></pre>

<p>yml
selector:
  app: hello-ms</p>

<pre><code>
To this:

</code></pre>

<p>yml
selector:
 deployment-config.name: hello-ms</p>

<pre><code>
We can do this the other way around, at the end is just a matter of taste. Next we need to expose our service:

</code></pre>

<p>oc expose svc hello-ms</p>

<h1 id="route-hello-ms-exposed">route &ldquo;hello-ms&rdquo; exposed</h1>

<p>oc get route</p>

<h1 id="name-host-port-path-services-port-termination-wildcard">NAME       HOST/PORT                         PATH      SERVICES   PORT      TERMINATION   WILDCARD</h1>

<h1 id="hello-ms-hello-ms-hello-127-0-0-1-nip-io-hello-ms-80-8080-none">hello-ms   hello-ms-hello.127.0.0.1.nip.io             hello-ms   80-8080                 None</h1>

<pre><code>
Now know the URL we can confidently make a ```curl``` to that address:  


</code></pre>

<p>curl hello-ms-hello.127.0.0.1.nip.io
Hello World%
```</p>

<p>Take a look at the complete process here:</p>

<p><img src="https://github.com/cesarvr/hugo-blog/blob/master/static/static/chaining-build/deploy.gif?raw=true" alt="deploy" /></p>

<p>Other ideas that come to my mind about how to take advantage of this decoupling is that you can maybe tag some specific nodes to with labels that match your <em>builder</em> image this way you focus all the resources to bring value back to your customer, and you have some specific resources to handle the software related duties.</p>
</div>
  <footer class="post-footer">
    
    <ul class="post-tags">
      
      <li><a href="/tags/openshift/">openshift</a></li>
      
      <li><a href="/tags/build/">build</a></li>
      
    </ul>
    
  </footer>
  
  
  
  
</article>
</main>
<footer class="footer">
  <span>&copy; 2019 Cesar Valdez</span>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/instantclick/3.0.1/instantclick.min.js" integrity="sha256-SVgP0duWZXZFPVIX+woWPFhpnHcxG5IXS6zvZAVoa3Y=" crossorigin="anonymous"></script>
<script data-no-instant>InstantClick.init();</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>
<script data-no-instant>
  hljs.initHighlightingOnLoad();
  addMenuListener();
  InstantClick.on('change', function() {
    var blocks = document.querySelectorAll('pre code');
    for (var i = 0; i < blocks.length; i++) {
      hljs.highlightBlock(blocks[i]);
    }
    addMenuListener();
  });
  function addMenuListener() {
    var $toggle = document.querySelector('.menu-toggle');
    var $body = document.querySelector('body');
    $toggle.addEventListener('click', function() {
      $body.classList.toggle('noscroll');
    }, false);
  }
</script>
</body>
</html>

