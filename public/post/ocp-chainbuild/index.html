<!DOCTYPE html>
<html lang="en">




<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>
    
    Chaining Builds In Openshift
     | Cesar 
  </title>
  <link rel="stylesheet" href='https://cesarvr.io/css/site.min.cc3fc5270f71da844cfcd512ac94081d2c969c9619b62a823c9279c7179b2d8fabd5b53456f25fa3c1586d19ce4255b5cb5f0dc927ee3b0b15d60065c50372fd.css' integrity='sha512-zD/FJw9x2oRM/NUSrJQIHSyWnJYZtiqCPJJ5xxebLY&#43;r1bU0VvJfo8FYbRnOQlW1y18NySfuOwsV1gBlxQNy/Q=='>
  <link rel="canonical" href="https://cesarvr.io/post/ocp-chainbuild/">
  <link rel="alternate" type="application/rss&#43;xml" href="https://cesarvr.io/index.xml" title="Happy Hacking">
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">
<meta name="author" content="Cesar">
<meta name="description" content="Using chained builds to improve the size of your images and overall deployment performance in Openshift.">

<meta property="og:title" content="Chaining Builds In Openshift" />
<meta property="og:description" content="Using chained builds to improve the size of your images and overall deployment performance in Openshift." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cesarvr.io/post/ocp-chainbuild/" />

<meta property="og:image" content="https://github.com/cesarvr/hugo-blog/blob/master/static/static/logo/ocp.png?raw=true" />
<meta property="article:published_time" content="2018-07-21T11:18:43+02:00" />
<meta property="article:modified_time" content="2018-08-02T10:45:32+01:00" />


</head>
<body><nav class="navbar is-transparent " role="navigation" aria-label="main navigation">
  <div class="navbar-brand">
    <a class="navbar-item" href="https://cesarvr.io/">
      <figure class="image">
        <img alt="" class="is-rounded" src="https://www.gravatar.com/avatar/a0c107b88dd0930e66b241a400e11bd2?s=128&d=identicon">
      </figure>
    </a>
    <a class="navbar-item" href="https://cesarvr.io/">
      Happy Hacking
    </a>
  </div>
  
  <div class="navbar-menu">
    <div class="navbar-start">
      
      <a class="navbar-item" href="https://cesarvr.io/tags/build/">
        
        Build
        
      </a>
      
      <a class="navbar-item" href="https://cesarvr.io/tags/containers/">
        
        Containers
        
      </a>
      
      <a class="navbar-item" href="https://cesarvr.io/tags/docker/">
        
        Docker
        
      </a>
      
      <a class="navbar-item" href="https://cesarvr.io/tags/openshift/">
        
        Openshift
        
      </a>
      
      <a class="navbar-item" href="https://cesarvr.io/tags/performance/">
        
        Performance
        
      </a>
      
      <a class="navbar-item" href="https://cesarvr.io/tags/programming/">
        
        Programming
        
      </a>
      
    </div>
    
    <div class="navbar-end">
      
      <a class="navbar-item" href="https://github.com/cesarvr" rel="noopener" target="_blank">
        <span class="icon">
          <img alt="github-circle" src='https://cesarvr.io/icons/svg/github-circle.svg'>
        </span>
      </a>
      
      <a class="navbar-item" href="https://www.linkedin.com/in/cesarvr/" rel="noopener" target="_blank">
        <span class="icon">
          <img alt="linkedin" src='https://cesarvr.io/icons/svg/linkedin.svg'>
        </span>
      </a>
      
      <a class="navbar-item" href="mailto:cesarv01@yahoo.com" target="_blank">
        <span class="icon">
          <img alt="email" src='https://cesarvr.io/icons/svg/email.svg'>
        </span>
      </a>
      <a class="navbar-item" href="https://cesarvr.io/index.xml" target="_blank">
        <span class="icon">
          <img alt="rss" src='https://cesarvr.io/icons/svg/rss.svg'>
        </span>
      </a>
      
    </div>
  </div>
</nav>
<section class="hero is-small is-info is-fullwidth">
  <div class="hero-body">
<div class="container">
  <h1 class="title">
    Chaining Builds In Openshift
  </h1>
  <h2 class="subtitle">
    <time datetime='2018-07-21T11:18:43&#43;02:00'>
      July 21, 2018
    </time>
    
    <br>
    
    
    
    <a class="tag is-link" href="https://cesarvr.io/tags/openshift/">openshift</a>
    
    
    
    
    <a class="tag is-link" href="https://cesarvr.io/tags/build/">build</a>
    
    
    
  </h2>
</div>

  </div>
</section>
<section class="section">
  <div class="container">
<div class="content is-medium">
  

<h2 id="new-application">New application</h2>

<p>Creating a Node.js application in Openshift is simple:</p>

<pre><code class="language-sh"> oc login -u user
 oc new-project hello

 # Assuming you are logged and you have a project you can start here.
 oc new-app --name node-app nodejs~https://github.com/cesarvr/hello-world-nodejs #new app using nodejs:latest (Node.js 8)
</code></pre>

<p>This command will create the backbone (BuildConfig, DeploymentConfig and Service) to orchestrate the different stages from source code to a running application.</p>

<h2 id="the-size-problem">The size problem</h2>

<p>But this nice abstraction come with a cost, to explain what I mean, let&rsquo;s review size of our final image using <a href="http://www.linfo.org/du.html">du</a>:</p>

<pre><code class="language-sh"># We log into our container and run
cd /
du -sh
474M	.
</code></pre>

<p>We found our image weight to much (474MB) relative to the amount of code we are running just (8 Byte).</p>

<pre><code class="language-js">require('http').createServer((req, res) =&gt; {
  res.end('Hello World')
}).listen(8080)
</code></pre>

<p>This happens because the tools we used at build (gcc, g++, npm, yum cache, etc.) are still present in the image inflating its final size. If you are just getting started as a developer in Openshift it may not be a big of a deal; also for quick proof of concepts is totally fine but it may have a cost for later stages like production that you may take into consideration.</p>

<h2 id="slim-is-better">Slim is better</h2>

<p>Some disadvantages of having a huge image are:</p>

<ul>
<li>Higher cost in CPU &amp; Ram to deploy your images.</li>
<li>If you have fixed resources bigger images slow deployments.</li>
<li>They add more stress on the cluster network.</li>
<li>Maintenance overhead. (You may end up maintaining dependencies your are not using)<br /></li>
</ul>

<p>If you need more reasons for more smaller containers:</p>

<p><a href="https://www.youtube.com/watch?v=wGz_cbtCiEA"><img src="https://img.youtube.com/vi/wGz_cbtCiEA/0.jpg" alt="Smaller Containers" /></a>)</p>

<h1 id="chaining-containers">Chaining containers</h1>

<p>The strategy to solve this problem is to have two images one with the tools to build the image and a second one with the essential libraries for runtime. Let&rsquo;s see how much we can improve those <strong>474M</strong>.</p>

<h2 id="builder-image">Builder image</h2>

<p>We can start by creating an image with the necessary tooling, we are going to call this image <code>builder</code>:</p>

<pre><code class="language-sh">oc new-build nodejs~https://github.com/cesarvr/hello-world-nodejs \
--context-dir=. \
--name=builder   
</code></pre>

<ul>
<li><pre><code class="language-nodejs```">
- The [repository for our code repository](https://github.com/cesarvr/hello-world-nodejs).

- ```context-dir``` This parameters tells where is the code.

This command will create two Openshift objects:


* **BuilderConfig** This object handle the image creation using [s2i](https://github.com/openshift/source-to-image).

</code></pre>

<p>sh</p></li>
</ul>

<p>#builder configuration
oc get bc<br />
NAME      TYPE       FROM      LATEST
builder   Source     Git         1</p>

<pre><code>
* **ImageStream** It's like the middleman between our image and everything else. After a successful build the resulting image is streamed here.

</code></pre>

<p>sh
oc get is
NAME          DOCKER REPO                         TAGS      UPDATED
builder       172.30.1.1:5000/hello/builder       latest    6 hours ago</p>

<pre><code>
Great!, we have our image with the tools we need. Next step is to trigger a build to prepare our application.  

![builder](https://github.com/cesarvr/hugo-blog/blob/master/static/static/chaining-build/build-tools.gif.gif?raw=true)

If everything is fine we should have all our Node.js artifacts inside a new image for us to consume, the nodejs base image we are using store the artifacts and our code in ```/opt/app-root/src/```.


## Runtime image

Now we need to create the image that will take care of the runtime. Let's start by explaining this version of the ``` oc new-build``` command:  

</code></pre>

<p>sh
oc new-build  &ndash;source-image=builder <br />
&ndash;source-image-path=[source-dir]:[destination-dir] <br />
&ndash;dockerfile=&lsquo;-&rsquo; &ndash;name=runtime</p>

<pre><code>
- ```source-image``` We want the [nodejs image we created above](#builder-image).
- ```--source-image-path``` We want to copy some files from [that image](#builder-image).
- ```dockerfile``` We want to create a new image using those files. Note: writing ```'dockerfile='-'``` will allow us to feed the Dockerfile via [standard input](https://en.wikipedia.org/wiki/Standard_streams#Standard_input_(stdin)).

Now that we know how to do it, we should create a file called [runtime.Dockerfile](https://gist.github.com/cesarvr/fac37fa7825f5ad7a576801fed07d0c8) to store the definition of our runtime container.

</code></pre>

<p>Dockerfile
FROM mhart/alpine-node:base-8
COPY * /run/
EXPOSE 8080
CMD [&ldquo;node&rdquo;, &ldquo;/run/app.js&rdquo;]</p>

<pre><code>
This file define a container using [mhart/alpine-node](https://hub.docker.com/r/mhart/alpine-node/) which is only 42 MB, next line copy the content from the *builder* image. The third and fourth line expose a port and run execute our script. This container image of course need more work to be production ready but is just fine for our purposes.


We execute the command:

</code></pre>

<p>sh
cat runtime.Dockerfile | oc new-build &ndash;name=runtime <br />
&ndash;source-image=builder <br />
&ndash;source-image-path=/opt/app-root/src:. <br />
&ndash;dockerfile=&lsquo;-&rsquo;</p>

<pre><code>
The content of [builder](#builder-image)*/opt/app-root/src/* is copy by the ```oc new-build``` into a temporary folder, then our Dockerfile use this folder as it's context folder. When we apply ```COPY * /run/``` we basically are copying the content of this folder into our new runtime container.


![runtime](https://github.com/cesarvr/hugo-blog/blob/master/static/static/chaining-build/runtime.gif?raw=true)


In the next animation you'll see how *builder* build configuration is now connected with *runtime* build. Every time *builder* push a new build of our software to the registry, it will be automatically packaged by *runtime*.

To trigger the *builder* build we just need to run:

</code></pre>

<p>oc start-build bc/builder</p>

<pre><code>
![chain](https://github.com/cesarvr/hugo-blog/blob/master/static/static/chaining-build/chain.gif?raw=true)



# Deploying our image

Is time to test if our hard work pays off. Deploying our image is very easy we just need to locate the URL of our *runtime* image in the registry:

</code></pre>

<p>sh
oc get is
#NAME          DOCKER REPO                         TAGS      UPDATED
#runtime       172.30.1.1:5000/hello/runtime       latest    15 hours ago</p>

<pre><code>
Having the address of our image, now we just simply call:

</code></pre>

<p>sh
oc create dc hello-ms &ndash;image=172.30.1.1:5000/hello/runtime</p>

<pre><code>
Now that we create our deployment object, we now need to send some traffic to our application. Before start sending traffic we need to identify by looking up is label.

</code></pre>

<p>sh
oc get dc hello-ms -o json | grep labels -A 3</p>

<h1 id="returns">returns</h1>

<p>&ldquo;labels&rdquo;: {
            &ldquo;deployment-config.name&rdquo;: &ldquo;hello-ms&rdquo;
          }</p>

<pre><code>
Now let create a service and send some traffic directed to this label:


</code></pre>

<p>sh
oc create service loadbalancer  hello-ms &ndash;tcp=80:8080</p>

<h1 id="service-hello-ms-created">service &ldquo;hello-ms&rdquo; created</h1>

<h1 id="edit-the-service-object">edit the service object</h1>

<p>oc edit svc hello-ms -o yaml</p>

<pre><code>
This will open the service object in yaml format in edit mode, we need to locate the *selector* and replace with the label of our deployment object.

From this:

</code></pre>

<p>yml
selector:
  app: hello-ms</p>

<pre><code>
To this:

</code></pre>

<p>yml
selector:
 deployment-config.name: hello-ms</p>

<pre><code>
We can do this the other way around, at the end is just a matter of taste. Next we need to expose our service:

</code></pre>

<p>oc expose svc hello-ms</p>

<h1 id="route-hello-ms-exposed">route &ldquo;hello-ms&rdquo; exposed</h1>

<p>oc get route</p>

<h1 id="name-host-port-path-services-port-termination-wildcard">NAME       HOST/PORT                         PATH      SERVICES   PORT      TERMINATION   WILDCARD</h1>

<h1 id="hello-ms-hello-ms-hello-127-0-0-1-nip-io-hello-ms-80-8080-none">hello-ms   hello-ms-hello.127.0.0.1.nip.io             hello-ms   80-8080                 None</h1>

<pre><code>
Now know the URL we can confidently make a ```curl``` to that address:  


</code></pre>

<p>curl hello-ms-hello.127.0.0.1.nip.io
Hello World%
```</p>

<p>Take a look at the complete process here:</p>

<p><img src="https://github.com/cesarvr/hugo-blog/blob/master/static/static/chaining-build/deploy.gif?raw=true" alt="deploy" /></p>

<p>Other ideas that come to my mind about how to take advantage of this decoupling is that you can maybe tag some specific nodes to with labels that match your <em>builder</em> image this way you focus all the resources to bring value back to your customer, and you have some specific resources to handle the software related duties.</p>

</div>


  </div>
</section><footer class="footer">
  <div class="content has-text-centered">
    
    <p>
      Last modified August 02, 2018
      
      (commit 358ab52)
      
    </p>
    
    
    <p>
      
      
    </p>
    
  </div>
</footer>


</body>
</html>
