<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  <title>Chaining Builds In Openshift - Terminal</title>
  


  <meta name="twitter:site" content="@cvaldezr">
  <meta name="twitter:creator" content="@cvaldezr">
  <meta name="twitter:description" content="Using chained builds to improve the size of your images and overall deployment performance in Openshift." />
  <meta name="twitter:title" content="Chaining Builds In Openshift" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:image" content="" />

  <meta property="og:title" content="Chaining Builds In Openshift" />
  <meta property="og:description" content="Using chained builds to improve the size of your images and overall deployment performance in Openshift." />
  <meta property="og:image" content="" />

  <meta name="description" content="New application Creating a Node.js application in Openshift is simple:
oc login -u user oc new-project hello # Assuming you are logged and you have a project you can start here. oc new-app --name node-app nodejs~https://github.com/cesarvr/hello-world-nodejs #new app using nodejs:latest (Node.js 8) This command will create the backbone (BuildConfig, DeploymentConfig and Service) to orchestrate the different stages from source code to a running application.
The size problem But this nice abstraction come with a cost, to explain what I mean, let&#39;s review size of our final image using du:">
  <meta name="author" content="Cesar">
  
  <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,700,700i" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/atom-one-dark.min.css" integrity="sha256-akwTLZec/XAFvgYgVH1T5/369lhA2Efr22xzCNl1nHs=" crossorigin="anonymous" />
  <link href="https://cesarvr.iocss/style.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/css/toastr.min.css" />

  
  <link rel="apple-touch-icon" href="https://cesarvr.ioimg/apple-touch-icon.png">
  <link rel="icon" href="https://cesarvr.ioimg/favicon.ico">
  
  <meta name="generator" content="Hugo 0.62.2" />
  
  <link rel="alternate" type="application/atom+xml" href="https://cesarvr.ioindex.xml" title="Terminal">
  
</head>
<body class="single">
  <header class="header">
    
    <p class="title"><a href="https://cesarvr.io">Terminal</a></p>
    
    <button class="menu-toggle" type="button"></button>
    <nav class="menu">
      <ul>
        
        
        <li class="">
          <a href="/about">About</a>
        </li>
        
        <li class="">
          <a href="/showcase">Showcase</a>
        </li>
        
      </ul>
    </nav>
  </header>
  <main class="main">

  <script
    			  src="https://code.jquery.com/jquery-3.3.1.min.js"
    			  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
    			  crossorigin="anonymous"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.js" async></script>
  <script src="https://cesarvr.iojs/db.js"></script>

<article class="post post-view">
  <header class="post-header">
    <h1 class="post-title">Chaining Builds In Openshift</h1>
    <p class="post-meta">Cesar Â· 2018.7.21</p>
  </header>
  <div class="post-content"><h2 id="new-application">New application</h2>
<p>Creating a Node.js application in Openshift is simple:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"> oc login -u user
 oc new-project hello

 <span style="color:#75715e"># Assuming you are logged and you have a project you can start here.</span>
 oc new-app --name node-app nodejs~https://github.com/cesarvr/hello-world-nodejs <span style="color:#75715e">#new app using nodejs:latest (Node.js 8)</span>
</code></pre></div><p>This command will create the backbone (BuildConfig, DeploymentConfig and Service) to orchestrate the different stages from source code to a running application.</p>
<h2 id="the-size-problem">The size problem</h2>
<p>But this nice abstraction come with a cost, to explain what I mean, let's review size of our final image using <a href="http://www.linfo.org/du.html">du</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e"># We log into our container and run</span>
cd /
du -sh
474M	.
</code></pre></div><p>We found our image weight to much (474MB) relative to the amount of code we are running just (8 Byte).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#39;http&#39;</span>).<span style="color:#a6e22e">createServer</span>((<span style="color:#a6e22e">req</span>, <span style="color:#a6e22e">res</span>) =&gt; {
  <span style="color:#a6e22e">res</span>.<span style="color:#a6e22e">end</span>(<span style="color:#e6db74">&#39;Hello World&#39;</span>)
}).<span style="color:#a6e22e">listen</span>(<span style="color:#ae81ff">8080</span>)
</code></pre></div><p>This happens because the tools we used at build (gcc, g++, npm, yum cache, etc.) are still present in the image inflating its final size. If you are just getting started as a developer in Openshift it may not be a big of a deal; also for quick proof of concepts is totally fine but it may have a cost for later stages like production that you may take into consideration.</p>
<h2 id="slim-is-better">Slim is better</h2>
<p>Some disadvantages of having a huge image are:</p>
<ul>
<li>Higher cost in CPU &amp; Ram to deploy your images.</li>
<li>If you have fixed resources bigger images slow deployments.</li>
<li>They add more stress on the cluster network.</li>
<li>Maintenance overhead. (You may end up maintaining dependencies your are not using)</li>
</ul>
<p>If you need more reasons for more smaller containers:</p>
<p><a href="https://www.youtube.com/watch?v=wGz_cbtCiEA"><img src="https://img.youtube.com/vi/wGz_cbtCiEA/0.jpg" alt="Smaller Containers"></a>)</p>
<h1 id="chaining-containers">Chaining containers</h1>
<p>The strategy to solve this problem is to have two images one with the tools to build the image and a second one with the essential libraries for runtime. Let's see how much we can improve those <strong>474M</strong>.</p>
<h2 id="builder-image">Builder image</h2>
<p>We can start by creating an image with the necessary tooling, we are going to call this image <code>builder</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">oc new-build nodejs~https://github.com/cesarvr/hello-world-nodejs <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>--context-dir<span style="color:#f92672">=</span>. <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>--name<span style="color:#f92672">=</span>builder   
</code></pre></div><ul>
<li>
<p><code>nodejs</code> New build using nodejs (Node.js 8) as our base image which include the tools we need to build our software.</p>
</li>
<li>
<p>The <a href="https://github.com/cesarvr/hello-world-nodejs">repository for our code repository</a>.</p>
</li>
<li>
<p><code>context-dir</code> This parameters tells where is the code.</p>
</li>
</ul>
<p>This command will create two Openshift objects:</p>
<ul>
<li><strong>BuilderConfig</strong> This object handle the image creation using <a href="https://github.com/openshift/source-to-image">s2i</a>.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e">#builder configuration</span>
oc get bc   
NAME      TYPE       FROM      LATEST
builder   Source     Git         <span style="color:#ae81ff">1</span>
</code></pre></div><ul>
<li><strong>ImageStream</strong> It's like the middleman between our image and everything else. After a successful build the resulting image is streamed here.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">oc get is
NAME          DOCKER REPO                         TAGS      UPDATED
builder       172.30.1.1:5000/hello/builder       latest    <span style="color:#ae81ff">6</span> hours ago
</code></pre></div><p>Great!, we have our image with the tools we need. Next step is to trigger a build to prepare our application.</p>
<p><img src="https://github.com/cesarvr/hugo-blog/blob/master/static/static/chaining-build/build-tools.gif.gif?raw=true" alt="builder"></p>
<p>If everything is fine we should have all our Node.js artifacts inside a new image for us to consume, the nodejs base image we are using store the artifacts and our code in <code>/opt/app-root/src/</code>.</p>
<h2 id="runtime-image">Runtime image</h2>
<p>Now we need to create the image that will take care of the runtime. Let's start by explaining this version of the <code> oc new-build</code> command:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">oc new-build  --source-image<span style="color:#f92672">=</span>builder <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>--source-image-path<span style="color:#f92672">=</span><span style="color:#f92672">[</span>source-dir<span style="color:#f92672">]</span>:<span style="color:#f92672">[</span>destination-dir<span style="color:#f92672">]</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>--dockerfile<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;-&#39;</span> --name<span style="color:#f92672">=</span>runtime
</code></pre></div><ul>
<li><code>source-image</code> We want the <a href="#builder-image">nodejs image we created above</a>.</li>
<li><code>--source-image-path</code> We want to copy some files from <a href="#builder-image">that image</a>.</li>
<li><code>dockerfile</code> We want to create a new image using those files. Note: writing <code>'dockerfile='-'</code> will allow us to feed the Dockerfile via <a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_input_(stdin)">standard input</a>.</li>
</ul>
<p>Now that we know how to do it, we should create a file called <a href="https://gist.github.com/cesarvr/fac37fa7825f5ad7a576801fed07d0c8">runtime.Dockerfile</a> to store the definition of our runtime container.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Dockerfile" data-lang="Dockerfile"><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> mhart/alpine-node:base-8</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> * /run/<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">EXPOSE</span><span style="color:#e6db74"> 8080</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">CMD</span> [<span style="color:#e6db74">&#34;node&#34;</span>, <span style="color:#e6db74">&#34;/run/app.js&#34;</span>]<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><p>This file define a container using <a href="https://hub.docker.com/r/mhart/alpine-node/">mhart/alpine-node</a> which is only 42 MB, next line copy the content from the <em>builder</em> image. The third and fourth line expose a port and run execute our script. This container image of course need more work to be production ready but is just fine for our purposes.</p>
<p>We execute the command:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">cat runtime.Dockerfile | oc new-build --name<span style="color:#f92672">=</span>runtime <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>--source-image<span style="color:#f92672">=</span>builder <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>--source-image-path<span style="color:#f92672">=</span>/opt/app-root/src:. <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>--dockerfile<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;-&#39;</span>
</code></pre></div><p>The content of <a href="#builder-image">builder</a><em>/opt/app-root/src/</em> is copy by the <code>oc new-build</code> into a temporary folder, then our Dockerfile use this folder as it's context folder. When we apply <code>COPY * /run/</code> we basically are copying the content of this folder into our new runtime container.</p>
<p><img src="https://github.com/cesarvr/hugo-blog/blob/master/static/static/chaining-build/runtime.gif?raw=true" alt="runtime"></p>
<p>In the next animation you'll see how <em>builder</em> build configuration is now connected with <em>runtime</em> build. Every time <em>builder</em> push a new build of our software to the registry, it will be automatically packaged by <em>runtime</em>.</p>
<p>To trigger the <em>builder</em> build we just need to run:</p>
<pre><code>oc start-build bc/builder
</code></pre><p><img src="https://github.com/cesarvr/hugo-blog/blob/master/static/static/chaining-build/chain.gif?raw=true" alt="chain"></p>
<h1 id="deploying-our-image">Deploying our image</h1>
<p>Is time to test if our hard work pays off. Deploying our image is very easy we just need to locate the URL of our <em>runtime</em> image in the registry:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">oc get is
<span style="color:#75715e">#NAME          DOCKER REPO                         TAGS      UPDATED</span>
<span style="color:#75715e">#runtime       172.30.1.1:5000/hello/runtime       latest    15 hours ago</span>
</code></pre></div><p>Having the address of our image, now we just simply call:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">oc create dc hello-ms --image<span style="color:#f92672">=</span>172.30.1.1:5000/hello/runtime
</code></pre></div><p>Now that we create our deployment object, we now need to send some traffic to our application. Before start sending traffic we need to identify by looking up is label.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">oc get dc hello-ms -o json | grep labels -A <span style="color:#ae81ff">3</span>
<span style="color:#75715e"># returns</span>
<span style="color:#e6db74">&#34;labels&#34;</span>: <span style="color:#f92672">{</span>
            <span style="color:#e6db74">&#34;deployment-config.name&#34;</span>: <span style="color:#e6db74">&#34;hello-ms&#34;</span>
          <span style="color:#f92672">}</span>
</code></pre></div><p>Now let create a service and send some traffic directed to this label:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">oc create service loadbalancer  hello-ms --tcp<span style="color:#f92672">=</span>80:8080
<span style="color:#75715e"># service &#34;hello-ms&#34; created</span>

<span style="color:#75715e"># edit the service object</span>
oc edit svc hello-ms -o yaml
</code></pre></div><p>This will open the service object in yaml format in edit mode, we need to locate the <em>selector</em> and replace with the label of our deployment object.</p>
<p>From this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml">selector:
  app: hello-ms
</code></pre></div><p>To this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml">selector:
 deployment-config.name: hello-ms
</code></pre></div><p>We can do this the other way around, at the end is just a matter of taste. Next we need to expose our service:</p>
<pre><code>oc expose svc hello-ms
# route &quot;hello-ms&quot; exposed

oc get route
# NAME       HOST/PORT                         PATH      SERVICES   PORT      TERMINATION   WILDCARD
# hello-ms   hello-ms-hello.127.0.0.1.nip.io             hello-ms   80-8080                 None
</code></pre><p>Now know the URL we can confidently make a <code>curl</code> to that address:</p>
<pre><code>curl hello-ms-hello.127.0.0.1.nip.io
Hello World%
</code></pre><p>Take a look at the complete process here:</p>
<p><img src="https://github.com/cesarvr/hugo-blog/blob/master/static/static/chaining-build/deploy.gif?raw=true" alt="deploy"></p>
<p>Other ideas that come to my mind about how to take advantage of this decoupling is that you can maybe tag some specific nodes to with labels that match your <em>builder</em> image this way you focus all the resources to bring value back to your customer, and you have some specific resources to handle the software related duties.</p>
</div>
  <footer class="post-footer">
    
    <ul class="post-tags">
      
      <li><a href="https://cesarvr.iotags/openshift/">openshift</a></li>
      
      <li><a href="https://cesarvr.iotags/build/">build</a></li>
      
    </ul>
    
  </footer>
  
  
  
  
</article>
</main>
<footer class="footer">
  <span>&copy; 2020 Cesar</span>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/instantclick/3.0.1/instantclick.min.js" integrity="sha256-SVgP0duWZXZFPVIX+woWPFhpnHcxG5IXS6zvZAVoa3Y=" crossorigin="anonymous"></script>
<script data-no-instant>InstantClick.init();</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>
<script data-no-instant>
  hljs.initHighlightingOnLoad();
  addMenuListener();
  InstantClick.on('change', function() {
    var blocks = document.querySelectorAll('pre code');
    for (var i = 0; i < blocks.length; i++) {
      hljs.highlightBlock(blocks[i]);
    }
    addMenuListener();
  });
  function addMenuListener() {
    var $toggle = document.querySelector('.menu-toggle');
    var $body = document.querySelector('body');
    $toggle.addEventListener('click', function() {
      $body.classList.toggle('noscroll');
    }, false);
  }
</script>
</body>
</html>

