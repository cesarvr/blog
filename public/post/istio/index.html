<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  <title>Creating Your Own Istio (Part 1) - Nube</title>
  


  <meta name="twitter:site" content="@cvaldezr">
  <meta name="twitter:creator" content="@cvaldezr">
  <meta name="twitter:description" content="How we can add/remove features to existing micro-services just by adding/removing containers." />
  <meta name="twitter:title" content="Creating Your Own Istio (Part 1)" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:image" content="https://github.com/cesarvr/hugo-blog/blob/master/static/static/logo/ocp.png?raw=true" />

  <meta name="description" content="Let say we have a micro-service exposing some business API, and we want to gather some data about its usage pattern such as how many time an endpoint is being called, what is latency, etc. One way to solve this require modifying the existing code base; adding the wanted behaviour in the form of a class or a set of functions (if functional is your thing), testing and re-deploying.

">
  <meta name="author" content="">
  
  <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,700,700i" rel="stylesheet">
  <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet">
  <link href="/css/style.css" rel="stylesheet">
  
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">
  <link rel="icon" href="/img/favicon.ico">
  
  <meta name="generator" content="Hugo 0.48" />
  
  <link rel="alternate" type="application/atom+xml" href="/index.xml" title="Nube">
  
</head>
<body class="single">
  <header class="header">
    
    <p class="title"><a href="/">Nube</a></p>
    
    <button class="menu-toggle" type="button"></button>
    <nav class="menu">
      <ul>
        
        
        <li class="">
          <a href="categories/">Categories</a>
        </li>
        
        <li class="">
          <a href="/about/">About</a>
        </li>
        
        <li class="">
          <a href="https://github.com/cesarvr">Code</a>
        </li>
        
        <li class="">
          <a href="/post/">Writing</a>
        </li>
        
      </ul>
    </nav>
  </header>
  <main class="main">

<article class="post post-view">
  <header class="post-header">
    <h1 class="post-title">Creating Your Own Istio (Part 1)</h1>
    <p class="post-meta">2018.9.19</p>
  </header>
  <div class="post-content"><p>Let say we have a micro-service exposing some business API, and we want to gather some data about its usage pattern such as how many time an endpoint is being called, what is latency, etc. One way to solve this require modifying the existing code base; adding the wanted behaviour in the form of a class or a set of functions (if functional is your thing), testing and re-deploying.</p>

<p></p>

<p>After successfully deploying this solution the question now is: <em>How can we reuse this functionality across all our micro-services ?</em> One way is to create a re-usable module, but that will require us to go through all the projects adding that specific module, which is hard work (testing, compatibility, etc.). <em>But what happen if I got services running in C++ and my solution is in Ruby?</em>  In that case, supporting multiple codebase sounds like a bad idea.</p>

<h1 id="separating-of-concerns">Separating Of Concerns</h1>

<p>An elegant solution can be to separate the new functionality into it&rsquo;s own container. In a way that we can add the container to those services that need this &ldquo;Telemetry&rdquo; information. This has some advantages, one is, we don&rsquo;t care about the programming language behind the service as long as we use the same protocol, second, all further enhancements are local to that container, and third, each container is specialized in their own domain.</p>

<p><em>But how we can create such container?</em> That&rsquo;s the answer this posts will try to respond. Pretty much like <strong>Istio</strong> or <put-here-your-service-mesh>, we are going to enhance existing services. The objective is to learn how to achieve some of the functionalities provided by Istio, so in the future you can replace them with your own ideas.</p>

<h2 id="simple-use-case-scenario">Simple Use Case Scenario</h2>

<p>If you need another example, imagine you want to enforce some <em>OAuth</em> across all your services, you can write a container that take care of that on behalf of your &ldquo;business&rdquo; container and you are done. <em>Do you want to change or upgrade the security protocol ?</em> Just change the code in one place and re-deploy.</p>

<h1 id="before-we-start">Before We Start</h1>

<p>This guide will be divide in three parts:</p>

<ul>
<li><strong>Part One</strong>: How to deploy applications that runs in multiple containers.<br /></li>
<li><strong>Part Two</strong>: We are going to develop a reusable &ldquo;Telemetry&rdquo; container, to gather information about other services.<br /></li>
<li><strong>Part Three</strong>: Write a simple dashboard. Once this &ldquo;Telemetry&rdquo; container is appended to other services, we are going to signal our dashboard with the usage information across our &ldquo;service mesh&rdquo;.<br /></li>
</ul>

<p>I&rsquo;m going to use OpenShift because is the Kubernetes distro I&rsquo;m most familiar with, but this techniques should also work in Kubernetes as well.</p>

<p>If you want to follow this guide you can install <a href="https://github.com/openshift/origin/blob/master/docs/cluster_up_down.md">oc-client</a> with oc-cluster-up or even better make a free account in <a href="https://manage.openshift.com">OpenShift.io</a>. If you have trouble understanding some of the concepts, you read this <a href="https://github.com/cesarvr/Openshift">OpenShift getting started guide</a>.</p>

<h1 id="understanding-the-pod">Understanding The Pod</h1>

<p>Pods are the building blocks to create applications in OpenShift, but for our purposes we can think of them as an container of containers, they provide a <a href="http://cesarvr.github.io/post/2018-05-22-create-containers/">isolation layer</a> similar to Linux container. This means that containers running inside the pods believe they are running in a single machine.</p>

<p>Like processes running in a &ldquo;single machine&rdquo;, contained processes can communicate between each other using some of the mechanism we can find in a Unix/Linux environment like System V semaphore, POSIX shared memory or Linux sockets. You can use this facts to achieve other type of collaboration between containers. In this article we are going to collaborate with other containers the local network through &ldquo;localhost&rdquo;.</p>

<h2 id="how-it-looks">How It Looks</h2>

<p>This is a quick example of what a <a href="https://gist.github.com/cesarvr/3e80053aca02c7ccd014cbdfc2288444">pod</a> looks like:</p>

<pre><code class="language-xml">apiVersion: v1
kind: Pod
metadata:
  name: my-pod
  labels:
    app: my-pod
spec:
  containers:
  - name: my-container
    image: busybox
    command: ['sh', '-c', 'echo Hello World! &amp;&amp; sleep 3600']
</code></pre>

<p>This YAML template defines a pod named <em>my-pod</em>, inside we are going to deploy a container using busybox (a very small Linux distribution) base image. Then we are going display &ldquo;Hello World&rdquo; and sleep to keep the entire container alive for 3 thousand seconds.</p>

<p>We save this in a file called pod.yml and we execute the following command:</p>

<pre><code class="language-sh">oc create -f pod.yml

# or you can create using a template stored somewhere else
oc create -f https://gist.githubusercontent.com/cesarvr/3e80053aca02c7ccd014cbdfc2288444/raw/52cde49116a6d6261a1f813034b957058180a7ee/pod.yml
</code></pre>

<p>That template creates the big jail (the pod) and once created it execute inside something similar to this: <code>docker run -it busybox echo Hello World!; sleep 3600</code>.</p>

<p>We can login into the pods running container using this <em>magic words</em>:</p>

<pre><code class="language-sh">oc rsh my-pod
</code></pre>

<h1 id="how-to-add-more-containers">How To Add More Containers</h1>

<p>Adding a new container to existing pod is not difficult, we just need add a new entry in the template:</p>

<pre><code class="language-xml">apiversion: v1
kind: pod
metadata:
  name: my-pod
  labels:
    app: my-pod
spec:
  containers:
  - name: first-container
    image: busybox
    command: ['sh', '-c', 'echo Hello World &amp;&amp; sleep 3600']
  - name: second-container
    image: busybox
    command: ['sh', '-c', 'echo Hello World 2 &amp;&amp; sleep 3600']
</code></pre>

<p>As you can observe that containers section is a collection, you can add as many containers as you want. After editing our template we just need to load the new template into OpenShift.</p>

<pre><code class="language-sh"># if you create a pod before, you need to deleted first.
oc delete pod my-pod

# create it again.
oc create -f pod.yml

#or

oc create -f https://gist.githubusercontent.com/cesarvr/97a0139ca2dba9412254d9919da64e69/raw/5e593a9a4b9fff9af06c53670f939fd9caef94ff/pod.yml
</code></pre>

<p>Logging into the pod gets a bit trickier now as we need to specify the container, let say we want to login into the <code>first-container</code> container:</p>

<pre><code class="language-sh">oc rsh -c first-container my-pod
</code></pre>

<p>If you want to login into the <code>second-container</code>:</p>

<pre><code class="language-sh">oc rsh -c second-container my-pod
</code></pre>

<h1 id="communication-between-pods">Communication Between Pods</h1>

<h2 id="simple-server">Simple Server</h2>

<p>By now we should understand all the theory behind how the pod works, so let&rsquo;s put some of it into practice and deploy a simple web server using python, first we need to build our image:</p>

<pre><code class="language-sh">  oc new-build python~https://github.com/cesarvr/demos-webgl --name=web
</code></pre>

<p>Here we are using <a href="https://cesarvr.io/post/buildconfig/">new-build</a> to create an image. We are going to provide this <a href="https://github.com/cesarvr/demos-webgl">repository</a>, where we got some simple HTTP pages.</p>

<p>We can check the location of our new image using the following command:</p>

<pre><code class="language-sh">oc get is

# NAME          DOCKER REPO                                             TAGS
# web           docker-registry.default.svc:5000/web-apps/web           latest    
</code></pre>

<p>Now we need to update our template to add our newly created image:</p>

<pre><code class="language-xml">apiversion: v1
kind: Pod
metadata:
  name: my-pod
  labels:
    app: my-pod
spec:
  containers:
  - name: web
    image: docker-registry.default.svc:5000/web-apps/web
    command: ['sh', '-c', 'echo Hello World &amp;&amp; sleep 3600']
  - name: proxy
    image: busybox
    command: ['sh', '-c', 'echo Hello World 2 &amp;&amp; sleep 3600']
</code></pre>

<p>Here I just renamed containers name for clarity, we got the <strong>web</strong> container using our Python image we created before, and the second container to <strong>proxy</strong>. The only thing left is to edit the command section in the <strong>web</strong> container so we deploy a web server instead of just showing a message.</p>

<pre><code class="language-xml">apiversion: v1
kind: Pod
metadata:
  name: my-pod
  labels:
    app: my-pod
spec:
  containers:
  - name: web
    image: docker-registry.default.svc:5000/web-apps/web
    command: ['sh', '-c', 'cd static &amp;&amp; python -m http.server 8087']
 - name: proxy
    image: busybox
    command: ['sh', '-c', 'echo Hello World 2 &amp;&amp; sleep 3600']
</code></pre>

<p>This command is very simple, once the container is created it will jump to the <a href="https://github.com/cesarvr/demos-webgl/tree/master/static">static folder</a> and then run the <a href="https://docs.python.org/3/library/http.server.html">HTTP.Server module</a>.</p>

<p>The only thing remaining is to re-create our pods:</p>

<pre><code class="language-sh">oc delete my-pod

oc create my-pod.yml
# or ...

oc create -f https://gist.githubusercontent.com/cesarvr/cecaf693a17b6f09b9eb3f5d38f33165/raw/2227781e4c3e71ecb68b22d052bdf8cd2c083c55/my-pod.yml
</code></pre>

<p>Now let&rsquo;s test that our containers can talk to each other inside the pod, for that we are going to the command <a href="https://docs.openshift.com/enterprise/3.0/dev_guide/executing_remote_commands.html">oc exec</a> (which is similar to <a href="https://dzone.com/articles/docker-for-beginners">docker exec</a> allow us to execute remote shell commands.</p>

<p>The syntax goes as follows:</p>

<pre><code class="language-sh">  oc exec -c &lt;container-name&gt; &lt;pod-name&gt; -- &lt;shell-command&gt;
</code></pre>

<p>Let&rsquo;s run <a href="https://www.computerhope.com/unix/wget.htm">wget</a> Linux command to fetch the webpage in our <strong>web</strong> container:</p>

<pre><code class="language-sh">oc exec -c web my-pod -- wget -qO- 0.0.0.0:8087

# &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;  
</code></pre>

<p>This means that our web server is running, now let&rsquo;s test same remote command with the <strong>proxy</strong> container and we should get the same result:</p>

<pre><code class="language-sh">oc exec -c proxy my-pod -- wget -qO- 0.0.0.0:8087

#&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;
</code></pre>

<p>Here is the whole process:</p>

<p><img src="https://raw.githubusercontent.com/cesarvr/hugo-blog/master/static/prometheus/sidecar-deployment.gif" alt="sidecar-deployment" /></p>

<h2 id="container-patterns">Container Patterns</h2>

<p>By now we achieved our first goal, we should be able to create applications with multiple containers, also another important point is that we demonstrate that containers running inside the pod share the same network. This is very important as we are going to use this in the next article to create our “Proxy” container to collect information about the usage of the website we deployed earlier.</p>

<p>If you want to know more about the container patterns you can take a look a this <a href="https://ai.google/research/pubs/pub45406">paper</a>.</p></div>
  <footer class="post-footer">
    
    <ul class="post-tags">
      
      <li><a href="/tags/openshift/">openshift</a></li>
      
      <li><a href="/tags/container/">container</a></li>
      
      <li><a href="/tags/services/">services</a></li>
      
      <li><a href="/tags/kubernetes/">kubernetes</a></li>
      
    </ul>
    
  </footer>
  
  
  
  
</article>
</main>
<footer class="footer">
  <span>&copy; 2018 Nube</span>
</footer>
<script src="https://cdn.bootcss.com/instantclick/3.0.1/instantclick.min.js" data-no-instant></script>
<script data-no-instant>InstantClick.init();</script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js" data-no-instant></script>
<script data-no-instant>
  hljs.initHighlightingOnLoad();
  addMenuListener();
  InstantClick.on('change', function() {
    var blocks = document.querySelectorAll('pre code');
    for (var i = 0; i < blocks.length; i++) {
      hljs.highlightBlock(blocks[i]);
    }
    addMenuListener();
  });
  function addMenuListener() {
    var $toggle = document.querySelector('.menu-toggle');
    var $body = document.querySelector('body');
    $toggle.addEventListener('click', function() {
      $body.classList.toggle('noscroll');
    }, false);
  }
</script>
</body>
</html>

